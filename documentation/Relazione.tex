\documentclass[12pt, a4paper, oneside]{book}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\renewcommand{\familydefault}{\sfdefault}

\usepackage[a4paper, margin=2.5cm]{geometry}

\usepackage{xcolor}
\definecolor{azzurrino}{HTML}{8B7355}
\definecolor{grigiochiaro}{HTML}{F5F5F5}
\definecolor{grigioscuro}{HTML}{424242}

\usepackage[
    colorlinks=true,
    linkcolor=grigioscuro,
    citecolor=azzurrino,
    urlcolor=azzurrino
]{hyperref}

\usepackage{titlesec}

\titleformat{\chapter}[display]
  {\normalfont\Huge\bfseries\color{azzurrino}}
  {\filleft\Huge\thechapter}
  {0pt}
  {\titlerule[1pt]\vspace{1ex}\filright}
  [\vspace{1ex}\titlerule]

\titleformat{\section}
  {\normalfont\Large\bfseries\color{azzurrino}}{\thesection}{1em}{}

\titleformat{\subsection}
  {\normalfont\large\bfseries\color{grigioscuro}}{\thesubsection}{1em}{}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\titleformat{\subsubsection}
  {\normalfont\large\bfseries\color{grigioscuro}}{\thesubsubsection}{1em}{}

\usepackage[font=small, labelfont={bf, color=azzurrino}]{caption}

\usepackage{fancyhdr}
\setlength{\headheight}{25pt}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\color{grigioscuro}\leftmark}
\fancyhead[R]{\color{azzurrino}\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\headrule}{\hbox to\headwidth{\color{azzurrino}\leaders\hrule height \headrulewidth\hfill}}

\usepackage{enumitem}
\setlist{nosep, leftmargin=1.5em}

\usepackage{graphicx}
\usepackage{bookmark}
\usepackage{float}
\usepackage{wrapfig}
\usepackage[normalem]{ulem}
\usepackage{subcaption}
\usepackage{soul}
\usepackage{parskip}
\usepackage{mdframed}

\usepackage[most]{tcolorbox}
\tcbuselibrary{listings, skins, breakable, theorems}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{longtable}
\usepackage{array}
\usepackage{tabularx}

% --- CORREZIONE TITOLO: Phtread -> Pthreads ---
\title{\Huge\bfseries \textcolor{azzurrino}{SHA-256} \\[0.5ex]
\textcolor{azzurrino}{Opzione 2: Pthreads \& FIFO} \\[1ex]
\Large UniVR - Dipartimento di Informatica \\[1.5ex]
\Large A.A. 2025/26}
\author{
\Large{Mattia Nicolis -- VR500356}
}
\date{}

% =================================
\begin{document}
    \frontmatter
    \maketitle
    \tableofcontents
    \thispagestyle{empty}
    \newpage

    %===========================
    \mainmatter

    \chapter{Introduzione}
    Il progetto consiste nella realizzazione di un sistema client-server per il calcolo concorrente dell'hash SHA-256.\\[0.2ex]
    L'obiettivo principale è massimizzare il throughput tramite un'architettura multithread, garantendo al contempo l'uso efficiente delle risorse e la robustezza del sistema.

    \chapter{Architettura e specifiche implementate}
    Il sistema è strutturato secondo un modello Master-Worker, dove un processo Server centrale gestisce le richieste provenienti da molteplici Client.

    \section{Componenti principali}
    \begin{itemize}
      \item \textbf{main thread (dispatcher)}: agisce come componente di smistamento.
      
      Si occupa esclusivamente di ascoltare la FIFO pubblica, deserializzare le richieste in arrivo e inserirle nella coda condivisa (\verb|request_queue|) per il successivo processamento.

      \medskip
      \item \textbf{worker threads}: thread pre-allocati (thread pool) che consumano le richieste dalla coda. 
      
      Ciascun worker è responsabile della verifica in cache, dell'eventuale calcolo CPU-intensive (SHA-256), dell'aggiornamento della cache e dell'invio della risposta sulla FIFO privata del client.
    \end{itemize}
    
    \section{Specifiche implementate}
    Le specifiche principali implementate includono:
    \begin{itemize}[label=$\triangleright$]
      \item \textbf{comunicazione Inter-Processo (IPC)}: utilizzo di una FIFO pubblica (\texttt{/tmp/sha256\_server\_fifo}) per le richieste e FIFO private univoche per le risposte, prevenendo deadlock comunicativi
      \medskip
      \item \textbf{gestione della concorrenza (thread pool)}: un main thread agisce da dispatcher, mentre un pool dinamico di worker threads (massimo 4) esegue i calcoli CPU-intensive
      \medskip
      \item \textbf{scheduling shortest job first (SJF)}: implementazione di una coda prioritaria che ordina le richieste in base alla dimensione del file, minimizzando il tempo di attesa medio
      \medskip
      \item \textbf{caching ($\boldsymbol{\text{O(1)}}$)}: memorizzazione dei risultati calcolati per evitare ricalcoli inutili su file già processati
      \medskip
      \item \textbf{introspezione e monitoraggio}: implementazione di un meccanismo di query (tramite un eseguibile ausiliario \verb|cache_query|) che permette all'amministratore di ispezionare in tempo reale lo stato della cache interna del server senza interrompere il servizio
    \end{itemize}

    \chapter{Scelte implementative e dettagli tecnici}
    In questa sezione si analizzano le soluzioni adottate per soddisfare i requisiti.

    \section{Gestione della concorrenza}
    Per garantire la correttezza dei dati (thread safety) e l'efficienza, è stato adottato il pattern \textbf{producer-consumer} con le seguenti caratteristiche:

    \begin{itemize}
      \item \textbf{mutua esclusione}: un singolo mutex globale (\verb|server_mutex|) protegge l'accesso concorrente alle strutture dati condivise: la \verb|request_queue| e la \verb|hash_cache|. 
      
      Questa scelta semplifica la logica di sincronizzazione prevenendo la \textbf{race conditions}.
      \smallskip
      \item \textbf{granularità del lock}: il mutex viene acquisito solo per le operazioni rapide di manipolazione delle liste. 
      
      Durante il calcolo oneroso dell'hash (SHA-256) e l'invio della risposta (I/O), il lock viene rilasciato. Questo permette un parallelismo reale: mentre un thread calcola, gli altri possono accedere alla coda o alla cache.
      \smallskip
      \item \textbf{attesa passiva}: Oltre al mutex, è stata utilizzata una \textbf{condition variable} (\verb|pthread_cond_t|). 
      
      I thread worker rimangono in stato di attesa (sleep) quando la coda è vuota, evitando lo spreco di CPU tipico del \textit{busy waiting}. 
      
      Vengono risvegliati dal dispatcher solo all'arrivo di una nuova richiesta.
    \end{itemize}

    \section{Scheduling e priorità (SJF)}
    Il cuore dell'ottimizzazione risiede nello scheduler. Invece di una classica coda FIFO (First-In First-Out), le richieste vengono gestite in base alla dimensione del file (\verb|file_size|):
    \begin{itemize}
      \item \textbf{implementazione}: l'ordinamento avviene tramite un algoritmo di \textbf{insertion sort} sulla lista linkata: la funzione \verb|enqueue_request| scansiona la lista e inserisce il nuovo nodo mantenendo l'ordine crescente
      \smallskip
      \item \textbf{vantaggio}: questo implementa la politica Shortest Job First (SJF), assicurando che i file piccoli non rimangano bloccati dietro a file di grandi dimensioni, migliorando il tempo di risposta medio del sistema
    \end{itemize}

    \section{Caching dei risultati}
    Per ridurre il carico sulla CPU, è stata implementata una cache in memoria (Linked List):
    \begin{itemize}
      \item \textbf{funzionamento}: prima di avviare il calcolo SHA-256, ogni worker thread controlla se il percorso del file è già presente nella lista \verb|hash_cache|
      \smallskip
      \item \textbf{cache Hit}: se il file è stato già elaborato in precedenza, il risultato viene restituito immediatamente, riducendo il tempo di servizio da $\text{O(N)}$ (dove N è la dimensione del file) a $\text{O(1)}$ (costante)
    \end{itemize}

    \chapter{Difficoltà riscontrate}
    Durante lo sviluppo sono emerse sfide critiche legate alla natura concorrente del progetto.

    \section{Sincronizzazione delle FIFO}
    Inizialmente, il server completava il calcolo ma il client rimaneva bloccato in attesa indefinita.\\[0.2ex]
    Il problema risiedeva nella gestione delle \verb|open()| bloccanti.\\[0.2ex]
    È stato necessario sincronizzare l'apertura in lettura del client con l'apertura in scrittura del server, garantendo che il canale fosse pronto prima dell'invio dei dati.

    \section{Gestione dei puntatori nella coda prioritaria}
    L'inserimento ordinato (SJF) in una lista linkata condivisa causava race conditions e corruzione della memoria.\\[0.2ex]
    L'implementazione ha richiesto una protezione rigorosa tramite mutex durante la scansione lineare ($\text{O(N)}$) per l'inserimento in testa o nel mezzo della lista.

    \section{Gestione delle eccezioni I/O e prevenzione crash}
    L'apertura diretta di un file inesistente da parte di un worker causava comportamenti indefiniti o terminazioni anomale del thread, lasciando potenzialmente il sistema instabile.\\[0.2ex]
    Il problema è stato risolto inserendo un controllo preventivo tramite la syscall \verb|access(F_OK)|. Questo funge da guardia (guard clause), permettendo al server di intercettare l'errore e rispondere al client con un codice \verb|"ERRORE_FILE_NOT_FOUND"| in modo controllato, senza compromettere il thread pool.

    \chapter{Test e risultati}
    Il sistema è stato collaudato verificando i casi d'uso principali e la gestione degli errori.
    
    \section{Verifica scheduling SJF}
    Lanciando in sequenza un file di grandi dimensioni (es. 100MB) seguito immediatamente da un file piccolo (es. 1MB), è stato verificato dai log del server che il file da 1MB viene processato e completato prima di quello più grande, confermando che la coda viene riordinata correttamente in base alla dimensione (\verb|file_size|).

    \section{Verifica del caching}
    Per verificare l'efficacia del caching, è stato effettuato un test sequenziale:
    \begin{enumerate}
      \item \textbf{prima richiesta}: il server calcola l'hash (tempo: proporzionale alla dimensione)
      \smallskip
      \item \textbf{seconda richiesta (stesso file)}: il server rileva il file nella lista \verb|hash_cache| e restituisce il risultato istantaneamente (tempo costante $\text{O(1)}$), senza rileggere il file da disco
    \end{enumerate}

    \section{Test di robustezza}
    È stato simulato l'invio di una richiesta per un file non presente sul server:
    \begin{itemize}
      \item \textbf{comando}: \verb|./client file_fantasma.txt|
      \item \textbf{risultato}: il server utilizza la funzione \verb|access()| per verificare l'esistenza del file prima di tentare l'apertura. 
      
      Invece di terminare in modo anomalo (crash), invia correttamente al client una stringa contenente l'errore, garantendo la stabilità del servizio.
    \end{itemize}

    \chapter{Guida alla compilazione e avvio}

    \section{Compilazione}
    Per generare i file eseguibili del progetto, seguire i seguenti comandi:
    \begin{tcolorbox}[
        title=Bash,
        colback=white,
        colframe=black,
        fonttitle=\bfseries
    ]
      \verb|mkdir <nome_cartella>|
      
      \verb|cd <nome_cartella>|
      
      \verb|cmake ..|
      
      \verb|make|
    \end{tcolorbox}

    Al termine dell'operazione, verranno generati tre eseguibili nella cartella \verb|build/|: \verb|server|, \verb|client| e \verb|cache_query|.

    \section{Esecuzione}
    Il sistema richieda l'apertura di terminali separati.
    \begin{tcolorbox}[
        title=Bash - terminale 1,
        colback=white,
        colframe=black,
        fonttitle=\bfseries
    ]
      \verb|./server|
    \end{tcolorbox}

    Il server inizializzerà la FIFO pubblica e si metterà in ascolto.

    In un secondo terminale, lanciare il client indicando il nome del file di cui si vuole calcolare l'hash:
    \begin{tcolorbox}[
        title=Bash - terminale 2,
        colback=white,
        colframe=black,
        fonttitle=\bfseries
    ]
      \verb|./client| \verb|percorso/nome_file.txt|
    \end{tcolorbox}

    Per verificare lo stato della memoria interna del server:
    \begin{tcolorbox}[
        title=Bash - terminale 3,
        colback=white,
        colframe=black,
        fonttitle=\bfseries
    ]
      \verb|./cache_query|
    \end{tcolorbox}
\end{document}